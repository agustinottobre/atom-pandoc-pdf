'use babel'

import path from 'path'
import electron from 'electron'
import fse from 'fs-extra'
import { BufferedProcess } from 'atom'
import crypto from 'crypto'
import os from 'os'


export default class PandocPdfProcessor {
  
  
  constructor(pathname, view) {
    // set associated view
    this.view = view
    // parse pathname into parts
    const pathnameParts = path.parse(pathname)
    
    // create temporary directory for Pandoc
    // with deterministic name
    this.tempDir = path.join(os.tmpdir(), 'pandoc-pdf-' +
      crypto.createHash('sha1').update(pathnameParts.dir).
        digest('hex').substring(0, 10) +
      '-' + pathnameParts.base)
    fse.ensureDirSync(this.tempDir)
    
    // set input filename
    this.inputFilename = pathnameParts.base
    // set pdf pathname
    this.pdfPathname = path.join(this.tempDir, pathnameParts.name + '.pdf')
    // set pathname for pdf save
    this.pdfSavePathname = path.join(
      pathnameParts.dir, pathnameParts.name + '.pdf')
    // set pathname for source defaults file
    this.defaultsPathname = path.join(
      pathnameParts.dir, pathnameParts.name + '.yaml')
    // set filename for source defaults file
    this.defaultsFilename = path.join(pathnameParts.name + '.yaml')

    // construct BufferedProcess options for Pandoc
    this.processOptions = {}
    // make resources (image files etc.) from the original directory available
    // by using it as Pandoc working directory
    this.processOptions.cwd = pathnameParts.dir
    // copy environment
    this.processOptions.env = {};
    for (e in process.env) {
      this.processOptions.env[e] = process.env[e];
    }
    // SOURCE_DATE_EPOCH (in Unix time format) determines the time that enters
    // the PDF ID generated by *latex, which in turn is used by the pdf.js
    // viewer as a key for storing the scroll position. Keeping this environment
    // variable constant over *latex invocations is necessary to prevent the
    // scroll position to be reset. We here use the time of the creation of the
    // PandocPdfProcessor.
    this.processOptions.env.SOURCE_DATE_EPOCH =
      Math.floor(Date.now() / 1000).toString()
    
    this.processing = false;
  }
  
  
  destroy() {
    // fse.removeSync(this.tempDir)
    if (this.processing) {
      this.process.kill()
    }
  }
  
  
  // open source defaults file in an Atom editor
  openDefaults() {
    atom.workspace.open(this.defaultsPathname)
  }
  
  
  // show temporary files in external file manager
  showFiles() {
    electron.shell.openItem(this.tempDir)
  }
  
  
  // copy generated PDF to user selected location
  async savePDF() {
    // if no PDF has been generated, do nothing
    if (!fse.pathExistsSync(this.pdfPathname)) {
      return
    }
    // offer to save with current savename
    result = await electron.remote.dialog.showSaveDialog(
      electron.remote.BrowserWindow.getFocusedWindow(), {
        'title': 'Save PDF',
        'defaultPath': this.pdfSavePathname,
        'buttonLabel': 'Save'
      })
    // if pathname selected or accepted
    if (result) {
      // set (new) savename
      this.pdfSavePathname = result
      // save PDF, i.e. copy to destination
      fse.copySync(this.pdfPathname, this.pdfSavePathname)
    }
  }
  
  
  // process file with Pandoc
  start() {
    // check whether already processing
    if (this.processing) {
      // if yes, stop old Pandoc process
      this.process.kill()
    }
    
    // record that processing has started
    this.processing = true
    
    // workaround for Pandoc not recreating the intermediate LaTeX file
    fse.removeSync(path.join(this.tempDir, 'input.tex'))
    
    // construct Pandoc call
    const command = 'pandoc'
    // file to process
    const args = [this.inputFilename]
    // PDF engine
    let writer
    switch (atom.config.get('pandoc-pdf.pandocPdfEngine')) {
      case 'Latexmk + pdfLaTeX':
        args.push('--pdf-engine=latexmk')
        args.push('--pdf-engine-opt=-pdf')
        args.push('--pdf-engine-opt=-output-directory=' + this.tempDir)
        writer = 'latex'
        break
      case 'Latexmk + XeLaTeX':
        args.push('--pdf-engine=latexmk')
        args.push('--pdf-engine-opt=-pdfxe')
        args.push('--pdf-engine-opt=-output-directory=' + this.tempDir)
        writer = 'latex'
        break
      case 'Latexmk + LuaLaTeX':
        args.push('--pdf-engine=latexmk')
        args.push('--pdf-engine-opt=-pdflua')
        args.push('--pdf-engine-opt=-output-directory=' + this.tempDir)
        writer = 'latex'
        break
      case 'ConTeXt + pdfTeX':
        args.push('--pdf-engine=context')
        args.push('--pdf-engine-opt=-pdftex')
        writer = 'context'
        break
      case 'ConTeXt + XeTeX':
        args.push('--pdf-engine=context')
        args.push('--pdf-engine-opt=-xetex')
        writer = 'context'
        break
      case 'ConTeXt + LuaTeX':
        args.push('--pdf-engine=context')
        writer = 'context'
        break
      case 'wkhtmltopdf':
        args.push('--pdf-engine=wkhtmltopdf')
        writer = 'html'
        break
      case 'WeasyPrint':
        args.push('--pdf-engine=weasyprint')
        writer = 'html'
        break
      case 'Prince':
        args.push('--pdf-engine=prince')
        writer = 'html'
        break
      case 'pdfroff':
        args.push('--pdf-engine=pdfroff')
        writer = 'ms'
        break
    }
    // beamer
    const regexpOption = atom.config.get('pandoc-pdf.pandocBeamer')
    if ((writer == 'latex') && (regexpOption)) {
      if (new RegExp(regexpOption).test(this.inputFilename)) {
        args.push('--write=beamer')
        writer = 'beamer'
      }
    }
    // template
    let templateOption = atom.config.get('pandoc-pdf.pandocTemplate')
    if (templateOption) {
      templateOption = templateOption.replace('${writer}', writer)
      args.push('--template=' + templateOption)
    }
    // general defaults
    let defaultsOption = atom.config.get('pandoc-pdf.pandocDefaults')
    if (defaultsOption) {
      defaultsOption = defaultsOption.replace('${writer}', writer)
      args.push('--defaults=' + defaultsOption)
    }
    // source-file-specific defaults
    if (fse.existsSync(this.defaultsPathname)) {
      args.push('--defaults=' + this.defaultsFilename)
    }
    // output file
    args.push('--output=' + this.pdfPathname)

    // call Pandoc
    this.view.logCall([command].concat(args))
    const options = this.processOptions
    const stdout = (output) => this.view.logStdout(output)
    const stderr = (output) => this.view.logStderr(output)
    const exit = (code) => this.finished(code)
    this.process = new BufferedProcess(
      {command, args, options, stdout, stderr, exit})
  }
  
  
  // called when processing has stopped
  async finished(code) {
    // update UI
    this.view.logExit(code)
    // record that processing has stopped
    this.processing = false
    if (code == 0) {
      // if successful, show (new version of) PDF
      pv = await atom.workspace.open(this.pdfPathname, {
        split: 'right',
        searchAllPanes: true,
        activatePane: false,
        activateItem: true
      })
      // workaround for package pdf-view, because auto-reload does not work
      if (typeof(pv.updatePdf) === 'function') {
        pv.updatePdf()
      }
    }
  }


}

'use babel'

import path from 'path'
import electron from 'electron'
import fse from 'fs-extra'
import { BufferedProcess } from 'atom'
import crypto from 'crypto'
import os from 'os'


export default class PandocPdfProcessor {


  constructor(pathname, view) {
    // set associated view
    this.view = view
    // parse pathname into parts
    const pathnameParts = path.parse(pathname)

    // create temporary directory for Pandoc
    // with deterministic name
    this.tempDir = path.join(os.tmpdir(), 'pandoc-pdf-' +
      crypto.createHash('sha1').update(pathnameParts.dir).
        digest('hex').substring(0, 10) +
      '-' + pathnameParts.base)
    fse.ensureDirSync(this.tempDir)

    // set input filename
    this.inputFilename = pathnameParts.base
    // set pdf filename
    this.pdfFilename = pathnameParts.name + '.pdf'
    // set pdf pathname
    this.pdfPathname = path.join(this.tempDir, this.pdfFilename)
    // set pathname for pdf save
    this.pdfSavePathname = path.join(
      pathnameParts.dir, pathnameParts.name + '.pdf')
    // set filename for source defaults file
    this.defaultsFilename = pathnameParts.name + '.yaml'
    // set pathname for source defaults file
    this.defaultsPathname = path.join(pathnameParts.dir, this.defaultsFilename)
    // set SyncTeX data pathname
    this.synctexPathname = path.join(
      this.tempDir, pathnameParts.name + '.synctex.gz')

    // determine explicit input format
    this.inputFormat = ''
    const inputFormats = atom.config.get('pandoc-pdf.pandocInputFormats')
    // list of extensions
    var exts = Object.keys(inputFormats)
    // sort extensions, but from the end of the string, so that
    // more specific entries (.talk.text) override less specific ones (.text)
    exts = exts.map(a => a.split('').reverse().join(''))
    exts = exts.sort()
    exts = exts.map(a => a.split('').reverse().join(''))
    // check whether extensions match
    for (let extKey of exts) {
      // extension keys must begin with '/' (standing for '.')
      if (extKey.startsWith('/')) {
        // decode for extension, '/' → '.'
        let ext = extKey.replace(/\//g, '.')
        // check whether extension matches
        if (pathnameParts.base.endsWith(ext)) {
          // if yes, remember associated format
          this.inputFormat = inputFormats[extKey]
          console.log('PandocPdfProcessor: "' + ext +
            '" matches → "' + this.inputFormat + '"')
        }
      }
    }

    // construct BufferedProcess options for Pandoc
    this.processOptions = {}
    // make resources (image files etc.) from the original directory available
    // by using it as Pandoc working directory
    this.processOptions.cwd = pathnameParts.dir
    // copy environment
    this.processOptions.env = {};
    for (e in process.env) {
      this.processOptions.env[e] = process.env[e];
    }
    // SOURCE_DATE_EPOCH (in Unix time format) determines the time that enters
    // the PDF ID generated by *latex, which in turn is used by the pdf.js
    // viewer as a key for storing the scroll position. Keeping this environment
    // variable constant over *latex invocations is necessary to prevent the
    // scroll position to be reset. We here use the time of the creation of the
    // PandocPdfProcessor.
    this.processOptions.env.SOURCE_DATE_EPOCH =
      Math.floor(Date.now() / 1000).toString()

    this.processing = false;
  }


  destroy() {
    if (this.processing) {
      this.process.kill()
    }
    // delete files in temporary directory except pdf
    fse.readdir(this.tempDir, (err, filenames) => {
      filenames.forEach(filename => {
        if (filename != this.pdfFilename) {
          fse.removeSync(path.join(this.tempDir, filename))
        }
      })
    })
  }


  // open source defaults file in an Atom editor
  openDefaults() {
    atom.workspace.open(this.defaultsPathname)
  }


  // show temporary files in external file manager
  showFiles() {
    electron.shell.openItem(this.tempDir)
  }


  // copy generated PDF to user selected location
  async savePDF() {
    // if no PDF has been generated, do nothing
    if (!fse.pathExistsSync(this.pdfPathname)) {
      return
    }
    // offer to save with current savename
    result = await electron.remote.dialog.showSaveDialog(
      electron.remote.BrowserWindow.getFocusedWindow(), {
        'title': 'Save PDF',
        'defaultPath': this.pdfSavePathname,
        'buttonLabel': 'Save'
      })
    // if pathname selected or accepted
    if (result && !result.canceled) {
      // set (new) savename
      this.pdfSavePathname = result.filePath
      console.log("saving '" + this.pdfPathname + "' to '" + this.pdfSavePathname + "'")
      // save PDF, i.e. copy to destination
      fse.copySync(this.pdfPathname, this.pdfSavePathname)
    }
  }


  // provide intermediate .tex pathname
  getTexPathname() {
    return path.join(this.tempDir, 'input.tex')
  }


  // process file with Pandoc
  start() {
    // check whether already processing
    if (this.processing) {
      // if yes, stop old Pandoc process
      this.process.kill()
    }

    // record that processing has started
    this.processing = true

    // workaround for Pandoc not recreating the intermediate .tex file
    fse.removeSync(this.getTexPathname())

    // determine writer from pandocPdfEngine
    let writer
    switch (atom.config.get('pandoc-pdf.pandocPdfEngine')) {
      case 'Latexmk + pdfLaTeX':
        writer = 'latex'
        break
      case 'Latexmk + XeLaTeX':
        writer = 'latex'
        break
      case 'Latexmk + LuaLaTeX':
        writer = 'latex'
        break
      case 'ConTeXt + pdfTeX':
        writer = 'context'
        break
      case 'ConTeXt + XeTeX':
        writer = 'context'
        break
      case 'ConTeXt + LuaTeX':
        writer = 'context'
        break
      case 'wkhtmltopdf':
        writer = 'html'
        break
      case 'WeasyPrint':
        writer = 'html'
        break
      case 'Prince':
        writer = 'html'
        break
      case 'pdfroff':
        writer = 'ms'
        break
    }
    // override by pandocBeamer
    const regexpOption = atom.config.get('pandoc-pdf.pandocBeamer')
    if ((writer == 'latex') && (regexpOption)) {
      if (new RegExp(regexpOption).test(this.inputFilename)) {
        writer = 'beamer'
      }
    }

    // construct Pandoc call
    const command = atom.config.get('pandoc-pdf.pandocPath')
    const args = []
    // template
    let templateOption = atom.config.get('pandoc-pdf.pandocTemplate')
    if (templateOption) {
      templateOption = templateOption.replace('${writer}', writer)
      args.push('--template=' + templateOption)
    }
    // general defaults
    let defaultsOption = atom.config.get('pandoc-pdf.pandocDefaults')
    if (defaultsOption) {
      defaultsOption = defaultsOption.replace('${writer}', writer)
      args.push('--defaults=' + defaultsOption)
    }
    // source-file-specific defaults
    if (fse.existsSync(this.defaultsPathname)) {
      args.push('--defaults=' + this.defaultsFilename)
    }
    // input format
    if (this.inputFormat != '') {
      args.push('--read=' + this.inputFormat)
    }
    // file to process
    args.push(this.inputFilename)
    // PDF engine
    switch (atom.config.get('pandoc-pdf.pandocPdfEngine')) {
      case 'Latexmk + pdfLaTeX':
        args.push('--pdf-engine=latexmk')
        args.push('--pdf-engine-opt=-pdf')
        args.push('--pdf-engine-opt=-output-directory=' + this.tempDir)
        break
      case 'Latexmk + XeLaTeX':
        args.push('--pdf-engine=latexmk')
        args.push('--pdf-engine-opt=-pdfxe')
        args.push('--pdf-engine-opt=-output-directory=' + this.tempDir)
        break
      case 'Latexmk + LuaLaTeX':
        args.push('--pdf-engine=latexmk')
        args.push('--pdf-engine-opt=-pdflua')
        args.push('--pdf-engine-opt=-output-directory=' + this.tempDir)
        break
      case 'ConTeXt + pdfTeX':
        args.push('--pdf-engine=context')
        args.push('--pdf-engine-opt=-pdftex')
        break
      case 'ConTeXt + XeTeX':
        args.push('--pdf-engine=context')
        args.push('--pdf-engine-opt=-xetex')
        break
      case 'ConTeXt + LuaTeX':
        args.push('--pdf-engine=context')
        break
      case 'wkhtmltopdf':
        args.push('--pdf-engine=wkhtmltopdf')
        break
      case 'WeasyPrint':
        args.push('--pdf-engine=weasyprint')
        break
      case 'Prince':
        args.push('--pdf-engine=prince')
        break
      case 'pdfroff':
        args.push('--pdf-engine=pdfroff')
        break
    }
    // output format
    args.push('--write=' + writer)
    // output file
    args.push('--output=' + this.pdfPathname)

    // call Pandoc
    this.view.logCall([command].concat(args))
    const options = this.processOptions
    const stdout = (output) => this.view.logStdout(output)
    const stderr = (output) => this.view.logStderr(output)
    const exit = (code) => this.finished(code)
    this.process = new BufferedProcess(
      {command, args, options, stdout, stderr, exit})
    this.process.onWillThrowError((errorObject) => {
        errorObject.handle()
        this.view.logStderr('Could not run Pandoc')
        this.view.logStderr('Make sure `' + command +
          '` is installed and on your PATH')
        this.finished(NaN)
      })
  }


  // called when processing has stopped
  async finished(code) {
    // update UI
    this.view.logExit(code)
    // record that processing has stopped
    this.processing = false
    if (code == 0) {
      // if successful, show (new version of) PDF
      pv = await atom.workspace.open(this.pdfPathname, {
        split: 'right',
        searchAllPanes: true,
        activatePane: false,
        activateItem: true
      })
      // workaround for package pdf-view, because auto-reload does not work
      if (typeof(pv.updatePdf) === 'function') {
        pv.updatePdf()
      }
    }
    // make SyncTeX work with respect to temporary LaTeX file
    //   Pandoc copies `input.pdf` to `<name>.pdf`, so that SyncTeX expects to
    // find `<name>.synctex.gz`; make it a symlink to `input.synctex.gz`.
    const synctex = path.join(this.tempDir, 'input.synctex.gz')
    if (fse.existsSync(synctex) && (!fse.existsSync(this.synctexPathname))) {
      fs.symlinkSync(synctex, this.synctexPathname)
    }
  }
}

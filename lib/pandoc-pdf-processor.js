'use babel'

import path from 'path'
import temp from 'temp'
import electron from 'electron'
import fse from 'fs-extra'
import { BufferedProcess } from 'atom'



export default class PandocPdfProcessor {
  
  
  constructor(pathname, view) {
    console.log('▶ PandocPdfViewProcessor constructor')
processor = this  // HACK
    
    // set input pathname
    this.pathname = pathname
    // set associated view
    this.view = view
    
    // create temporary directory for Pandoc
    temp.track()
    this.temp = temp.mkdirSync()
    
    // parse pathname into parts
    this.parts = path.parse(this.pathname)
    // set pdf pathname
    this.pdfname = path.join(this.temp, this.parts.name + '.pdf')
    // set pathname for pdf save
    this.savename = path.join(this.parts.dir, this.parts.name + '.pdf')
    // set pathname for source defaults file
    this.defaults = path.join(this.parts.dir, this.parts.name + '.yaml')

    // construct BufferedProcess options for Pandoc
    this.options = {}
    // make resources (image files etc.) from the original directory available
    // by using it as Pandoc working directory
    this.options.cwd = this.parts.dir
    // copy environment
    this.options.env = {};
    for (e in process.env) {
      this.options.env[e] = process.env[e];
    }
    // SOURCE_DATE_EPOCH (in Unix time format) determines the time that enters
    // the PDF ID generated by *latex, which in turn is used by the pdf.js
    // viewer as a key for storing the scroll position. Keeping this environment
    // variable constant over *latex invocations is necessary to prevent the
    // scroll position to be reset. We here use the time of the creation of the
    // PandocPdfProcessor.
    this.options.env.SOURCE_DATE_EPOCH=Math.floor(Date.now() / 1000).toString()
    
    this.processing = false;

    console.log('◀ PandocPdfViewProcessor constructor')
  }
  
  
  destroy() {
    console.log('▶ PandocPdfViewProcessor destroy')
    
    temp.cleanupSync()
    
    console.log('◀ PandocPdfViewProcessor destroy')
  }
  
  
  // open source defaults file in an Atom editor
  openDefaults() {
    atom.workspace.open(this.defaults)
  }
  
  
  // show temporary files in external file manager
  showFiles() {
    electron.shell.openItem(this.temp)
  }
  
  
  // copy generated PDF to user selected location
  async savePDF() {
    // offer to save with current savename
    result = await electron.remote.dialog.showSaveDialog(
      electron.remote.BrowserWindow.getFocusedWindow(), {
        "title": "Save PDF",
        "defaultPath": this.savename,
        "buttonLabel": "Save"
      })
    // if pathname selected or accepted
    if (result) {
      // set (new) savename
      this.savename = result
      // save PDF, i.e. copy to destination
      fse.copySync(this.pdfname, this.savename)
    }
  }
  
  
  // run Pandoc on file
  start() {
    console.log('▶ PandocPdfViewProcessor start')
    
    // check whether already processing
    if (this.processing) {
      // if yes, stop process
      this.process.kill()
    }
    this.processing = true
    
    // delete old intermediate file (FIXME why is this necessary?)
    // to be on the safe side, delete all temporary files
    fse.emptyDirSync(this.temp)
    
    // construct Pandoc call
    const command = 'pandoc'
    // file to process
    const args = [this.pathname]
    // PDF engine
    let writer
    switch (atom.config.get('pandoc-pdf.pandocPdfEngine')) {
      case "Latexmk + pdfLaTeX":
        args.push("--pdf-engine=latexmk")
        args.push("--pdf-engine-opt=-pdf")
        args.push("--pdf-engine-opt=-gg")
        args.push("--pdf-engine-opt=-output-directory=" + this.temp)
        writer = "latex"
        break
      case "Latexmk + XeLaTeX":
        args.push("--pdf-engine=latexmk")
        args.push("--pdf-engine-opt=-pdfxe")
        args.push("--pdf-engine-opt=-gg")
        args.push("--pdf-engine-opt=-output-directory=" + this.temp)
        writer = "latex"
        break
      case "Latexmk + LuaLaTeX":
        args.push("--pdf-engine=latexmk")
        args.push("--pdf-engine-opt=-pdflua")
        args.push("--pdf-engine-opt=-gg")
        args.push("--pdf-engine-opt=-output-directory=" + this.temp)
        writer = "latex"
        break
      case "ConTeXt + pdfTeX":
        args.push("--pdf-engine=context")
        args.push("--pdf-engine-opt=-pdftex")
        writer = "context"
        break
      case "ConTeXt + XeTeX":
        args.push("--pdf-engine=context")
        args.push("--pdf-engine-opt=-xetex")
        writer = "context"
        break
      case "ConTeXt + LuaTeX":
        args.push("--pdf-engine=context")
        writer = "context"
        break
      case "wkhtmltopdf":
        args.push("--pdf-engine=wkhtmltopdf")
        writer = "html"
        break
      case "WeasyPrint":
        args.push("--pdf-engine=weasyprint")
        writer = "html"
        break
      case "Prince":
        args.push("--pdf-engine=prince")
        writer = "html"
        break
      case "pdfroff":
        args.push("--pdf-engine=pdfroff")
        writer = "ms"
        break
    }
    // beamer
    const regexp = atom.config.get('pandoc-pdf.pandocBeamer')
    if ((writer == 'latex') && (regexp)) {
      if (new RegExp(regexp).test(this.pathname)) {
        args.push("--write=beamer")
        writer = 'beamer'
      }
    }
    // template
    let template = atom.config.get('pandoc-pdf.pandocTemplate')
    if (template) {
      template = template.replace('${writer}', writer)
      args.push("--template=" + template)
    }
    // general defaults
    let defaults = atom.config.get('pandoc-pdf.pandocDefaults')
    if (defaults) {
      defaults = defaults.replace('${writer}', writer)
      args.push("--defaults=" + defaults)
    }
    // source-file-specific defaults
    if (atom.config.get('pandoc-pdf.pandocSourceDefaults')) {
      if (fse.existsSync(this.defaults)) {
        args.push("--defaults=" + this.defaults)
      }
    }
    // output file
    args.push('--output=' + this.pdfname)
    

    // call Pandoc
    this.view.logCall([command].concat(args))
    const options = this.options
    const stdout = (output) => this.view.logStdout(output)
    const stderr = (output) => this.view.logStderr(output)
    const exit = (code) => this.finished(code)
    this.process = new BufferedProcess(
      {command, args, options, stdout, stderr, exit})
      
    console.log('◀ PandocPdfViewProcessor start')
  }
  
  
  finished(code) {
    this.view.logExit(code)
    
    this.processing = false
  }


}
